### Script to process FTICR-MS reports generated by Formularity (ToliÄ‡ et al, 2017 - Anal. Chem.)

require(ftmsRanalysis) # package found at https://github.com/EMSL-Computing/ftmsRanalysis
require(easycsv)
require(tidyverse)
source("C:/Users/gara009/OneDrive - PNNL/Documents/ECA_all_samples_4-13-2021/Rcode/getLambda.R")

# Switches
Sample_Name = "ECA_Sediment_Extractions" # Sample name for output
min_mass = 200
summary = T # This is a switch which will generate compound class and characteristics summary files

### Load in data ###
setwd(easycsv::choose_dir())
report = read.csv(file = list.files(path = ".", pattern = "*Report.csv", full.names = T))

# Separating molecular information and peak data
emeta = report[, c("Mass", "C", "H", "O", "N", "C13", "S", "P", "Na", "El_comp", 
               "Class", "NeutralMass", "Error_ppm", "Candidates")]
edata = report[,-which(colnames(report) %in% c("C", "H", "O", "N", "C13", "S", "P", "Na", "El_comp", 
                                          "Class", "NeutralMass", "Error_ppm", "Candidates"))]
rm("report") # Removing report

#### Creating empty factors data ####
fdata = data.frame(Sample_ID = colnames(edata)[-1], Location = "Somewhere")

### Convert data and remove isotopic peaks ###
peak_icr = as.peakData(e_data = edata, f_data = fdata, e_meta = emeta, edata_cname = "Mass", mass_cname = "Mass",
                          fdata_cname = "Sample_ID", c_cname = "C", h_cname = "H", o_cname = "O", n_cname = "N", s_cname = "S",
                          p_cname = "P", isotopic_cname = "C13", isotopic_notation = "1")

### Calculating derived statistics ####
peak_icr = compound_calcs(peak_icr)

### Assigning compound classes ###
peak_icr = assign_class(peak_icr, boundary_set = "bs1")
peak_icr = assign_class(peak_icr, boundary_set = "bs2")
peak_icr = assign_class(peak_icr, boundary_set = "bs3")

### Filtering peaks ###
filter_obj = mass_filter(peak_icr)
peak_icr = applyFilt(filter_obj, peak_icr, min_mass = min_mass, max_mass = 900)

### Setting peak_icr objects and row names ###
edata = peak_icr$e_data # I can't guarantee it right now, but I don't think these two lines are necessary...
emeta = peak_icr$e_meta

### Calculating lambda ###
get_comp = get_compositions(emeta)
lambda = as.data.frame(get_lambda(get_comp$chemical_compositions))
names <- rep("", 62)

names[1:12] <- c("delGcox0","delGd0","delGcat0","delGan0","delGdis0","lambda0",
                 "delGcox","delGd","delGcat","delGan","delGdis","lambda")

stoich_colnames <- c("donor","h2o","hco3","nh4","hpo4","hs","h","e","acceptor","biom")
stoich_types <- c("stoichD","stoichA","stoichCat","stoichAn","stoichMet")

for (i in 1:length(stoich_types)) {
  names[((i-1)*10+13):(i*10+12)] <- array(sapply(stoich_types[i], paste, stoich_colnames, sep="_"))
}
colnames(lambda) <- names
lambda['MolForm'] <- get_comp$formulas
lambda = as.data.frame(lambda[,c("MolForm", "delGcox0", "delGcox", "lambda0", "lambda", "delGd0", "delGd")])
colnames(lambda) = c("MolForm","delGcox0PerCmol","delGcoxPerCmol", "lamO20","lamO2","delGd0","delGd")
lambda = lambda[!duplicated(lambda$MolForm),]

### Adding lambda information into emeta data ###
emeta = emeta %>% left_join(lambda, by = "MolForm")

colnames(edata) = gsub("_ReSPE", "", colnames(edata)) 

## Write results ###
write.csv(edata, paste("Processed_", Sample_Name, "_Data.csv", sep = ""), quote = F, row.names = F)
write.csv(emeta, paste("Processed_", Sample_Name, "_Mol.csv", sep = ""), quote = F, row.names = F)

write.table(c(paste("This processed output was generated by removing isotopic peaks and filtering masses outside", min_mass, "- 900"),
            "Processing_log.txt"), quote = F, row.names = F)

############### Summary generation ############### 

if(summary == T){
  
  # Storing row names
  row.names(edata) = edata$Mass; edata = edata[,-which(colnames(edata) %in% "Mass")]
  row.names(emeta) = emeta$Mass; emeta = emeta[,-which(colnames(emeta) %in% "Mass")]
  
  #### Compound class summary
  # Finding unique compound classes
  uniq.comp = unique(peak_icr$e_meta$bs1_class)
  
  # Looping through each sample to obtain some summary categoreies
  classes = matrix(nrow = ncol(edata), ncol = length(uniq.comp)) # Creating empty matrix to store stats
  colnames(classes) = uniq.comp
  row.names(classes) = colnames(edata)
  
  name.temp = NULL
  
  for(i in 1:ncol(edata)){
    temp = edata[which(edata[,i] > 0), i, drop = F] # Need to keep names, looking at columns
    temp = emeta[which(row.names(emeta) %in% row.names(temp)),]
    
    for(j in 1:length(uniq.comp)){
      classes[i,j] = length(which(temp$bs1 %in% uniq.comp[j]))
    }
    
    name.temp = c(name.temp, colnames(edata)[i])
  } # I'm not sure how to do this without the for-loop, but I'm simply just finding the mean/median for peak stats
  
  classes = as.data.frame(classes)
  
  write.csv(classes, paste(Sample_Name, "_Compound_Class_Summary.csv", sep = ""), quote = F)
  
  
  #### Elemental Composition Summary
  uniq.elem = unique(peak_icr$e_meta$El_comp)
  uniq.elem = uniq.elem[-which(uniq.elem %in% "")]
  
  # Looping through each sample to obtain some summary categoreies
  elem.comp = matrix(nrow = ncol(edata), ncol = length(uniq.elem)) # Creating empty matrix to store stats
  colnames(elem.comp) = uniq.elem
  row.names(elem.comp) = colnames(edata)
  
  name.temp = NULL
  
  for(i in 1:ncol(edata)){
    temp = edata[which(edata[,i] > 0), i, drop = F] # Need to keep names, looking at columns
    temp = emeta[which(row.names(emeta) %in% row.names(temp)),]
    
    for(j in 1:length(uniq.elem)){
      elem.comp[i,j] = length(which(temp$El_comp %in% uniq.elem[j]))
    }
    
    name.temp = c(name.temp, colnames(edata)[i])
  } # I'm not sure how to do this without the for-loop, but I'm simply just finding the mean/median for peak stats
  
  elem.comp = as.data.frame(elem.comp)
  
  write.csv(elem.comp, paste(Sample_Name, "_Elemental_Composition_Summary.csv", sep = ""), quote = F)
  
  
  #### Characteristics summary
  # Looping through each sample to obtain some summary stats of the peaks
  characteristics = data.frame(AI.mean = rep(NA, length(colnames(edata))), AI.median = NA, AI.sd = NA,
                               AI_Mod.mean = NA, AI_Mod.median = NA, AI_Mod.sd = NA,
                               DBE.mean = NA, DBE.median = NA, DBE.sd = NA,
                               DBE_O.mean = NA, DBE_O.median = NA, DBE_O.sd = NA,
                               KenMass.mean = NA, KenMass.median = NA, KenMass.sd = NA,
                               KenDef.mean = NA, KenDef.median = NA, KenDef.sd = NA,
                               NOSC.mean = NA, NOSC.median = NA, NOSC.sd = NA,
                               HtoC.mean = NA, HtoC.median = NA, HtoC.sd = NA,
                               OtoC.mean = NA, OtoC.median = NA, OtoC.sd = NA,
                               NtoC.mean = NA, NtoC.median = NA, NtoC.sd = NA,
                               PtoC.mean = NA, PtoC.median = NA, PtoC.sd = NA,
                               NtoP.mean = NA, NtoP.median = NA, NtoP.sd = NA,
                               GFE_0.mean = NA, GFE_0.median = NA, GFE_0.sd = NA,
                               GFE_7.mean = NA, GFE_7.median = NA, GFE_7.sd = NA,
                               GFEperC_0.mean = NA, GFEperC_0.median = NA, GFEperC_0.sd = NA,
                               GFEperC_7.mean = NA, GFEperC_7.median = NA, GFEperC_7.sd = NA,
                               lambdaO2_0.mean = NA, lambdaO2_0.median = NA, lambdaO2_0.sd = NA,
                               lambdaO2_7.mean = NA, lambdaO2_7.median = NA, lambdaO2_7.sd = NA,
                               row.names = colnames(edata))
  
  for(i in 1:ncol(edata)){
    temp = edata[which(edata[,i] > 0), i, drop = F] # Need to keep names, looking at columns
    temp = emeta[row.names(temp),]
    
    # AI
    characteristics$AI.mean[i] = mean(temp$AI, na.rm = T)
    characteristics$AI.median[i] = median(temp$AI, na.rm = T)
    characteristics$AI.sd[i] = sd(temp$AI, na.rm = T)
    
    # AI_Mod
    characteristics$AI_Mod.mean[i] = mean(temp$AI_Mod, na.rm = T)
    characteristics$AI_Mod.median[i] = median(temp$AI_Mod, na.rm = T)
    characteristics$AI_Mod.sd[i] = sd(temp$AI_Mod, na.rm = T)
    
    # DBE
    characteristics$DBE.mean[i] = mean(temp$DBE, na.rm = T)
    characteristics$DBE.median[i] = median(temp$DBE, na.rm = T)
    characteristics$DBE.sd[i] = sd(temp$DBE, na.rm = T)
    
    # DBE-O
    characteristics$DBE_O.mean[i] = mean(temp$DBE_O, na.rm = T)
    characteristics$DBE_O.median[i] = median(temp$DBE_O, na.rm = T)
    characteristics$DBE_O.sd[i] = sd(temp$DBE_O, na.rm = T)
    
    # Kendrick Mass
    characteristics$KenMass.mean[i] = mean(temp$kmass, na.rm = T)
    characteristics$KenMass.median[i] = median(temp$kmass, na.rm = T)
    characteristics$KenMass.sd[i] = sd(temp$kmass, na.rm = T)
    
    # Kendrick Defect
    characteristics$KenDef.mean[i] = mean(temp$kdefect, na.rm = T)
    characteristics$KenDef.median[i] = median(temp$kdefect, na.rm = T)
    characteristics$KenDef.sd[i] = sd(temp$kdefect, na.rm = T)
    
    # NOSC
    characteristics$NOSC.mean[i] = mean(temp$NOSC, na.rm = T)
    characteristics$NOSC.median[i] = median(temp$NOSC, na.rm = T)
    characteristics$NOSC.sd[i] = sd(temp$NOSC, na.rm = T)
    
    # H:C Ratio
    characteristics$HtoC.mean[i] = mean(temp$HtoC_ratio, na.rm = T)
    characteristics$HtoC.median[i] = median(temp$HtoC_ratio, na.rm = T)
    characteristics$HtoC.sd[i] = sd(temp$HtoC_ratio, na.rm = T)
    
    # O:C Ratio
    characteristics$OtoC.mean[i] = mean(temp$OtoC_ratio, na.rm = T)
    characteristics$OtoC.median[i] = median(temp$OtoC_ratio, na.rm = T)
    characteristics$OtoC.sd[i] = sd(temp$OtoC_ratio, na.rm = T)
    
    # N:C Ratio
    characteristics$NtoC.mean[i] = mean(temp$NtoC_ratio, na.rm = T)
    characteristics$NtoC.median[i] = median(temp$NtoC_ratio, na.rm = T)
    characteristics$NtoC.sd[i] = sd(temp$NtoC_ratio, na.rm = T)
    
    # P:C Ratio
    characteristics$PtoC.mean[i] = mean(temp$PtoC_ratio, na.rm = T)
    characteristics$PtoC.median[i] = median(temp$PtoC_ratio, na.rm = T)
    characteristics$PtoC.sd[i] = sd(temp$PtoC_ratio, na.rm = T)
    
    # N:P Ratio
    characteristics$NtoP.mean[i] = mean(temp$NtoP_ratio, na.rm = T)
    characteristics$NtoP.median[i] = median(temp$NtoP_ratio, na.rm = T)
    characteristics$NtoP.sd[i] = sd(temp$NtoP_ratio, na.rm = T)
    
    # GFE_0
    characteristics$GFE_0.mean[i] = mean(temp$delGd0, na.rm = T)
    characteristics$GFE_0.median[i] = median(temp$delGd0, na.rm = T)
    characteristics$GFE_0.sd[i] = sd(temp$delGd0, na.rm = T)
    
    # GFE_7
    characteristics$GFE_7.mean[i] = mean(temp$delGd, na.rm = T)
    characteristics$GFE_7.median[i] = median(temp$delGd, na.rm = T)
    characteristics$GFE_7.sd[i] = sd(temp$delGd, na.rm = T)
    
    # GFEperC_0
    characteristics$GFEperC_0.mean[i] = mean(temp$delGcox0PerCmol, na.rm = T)
    characteristics$GFEperC_0.median[i] = median(temp$delGcox0PerCmol, na.rm = T)
    characteristics$GFEperC_0.sd[i] = sd(temp$delGcox0PerCmol, na.rm = T)
    
    # GFEperC_7
    characteristics$GFEperC_7.mean[i] = mean(temp$delGcoxPerCmol, na.rm = T)
    characteristics$GFEperC_7.median[i] = median(temp$delGcoxPerCmol, na.rm = T)
    characteristics$GFEperC_7.sd[i] = sd(temp$delGcoxPerCmol, na.rm = T)
    
    # lambdaO2_0
    characteristics$lambdaO2_0.mean[i] = mean(temp$lamO20, na.rm = T)
    characteristics$lambdaO2_0.median[i] = median(temp$lamO20, na.rm = T)
    characteristics$lambdaO2_0.sd[i] = sd(temp$lamO20, na.rm = T)
    
    # lambda02_7
    characteristics$lambdaO2_7.mean[i] = mean(temp$lamO2, na.rm = T)
    characteristics$lambdaO2_7.median[i] = median(temp$lamO2, na.rm = T)
    characteristics$lambdaO2_7.sd[i] = sd(temp$lamO2, na.rm = T)
    
  } # I'm not sure how to do this without the for-loop, but I'm simply just finding the mean/median for peak stats
  
  write.csv(characteristics, paste(Sample_Name, "_MolInfo_Summary.csv", sep = ""), quote = F)
  
}
